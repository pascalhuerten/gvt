<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>EA9 | Torustextur | Pascal Hürten</title>
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="../ea2/style.css">
    <style>
        .math-formula {
            background: #f5f5f5;
            padding: 12px;
            margin: 10px 0;
            border-left: 4px solid #0066cc;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            overflow-x: auto;
        }

        .shape-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .shape-section h4 {
            margin-top: 0;
            color: #0066cc;
        }
    </style>

    <!-- libraries & geometry generators -->
    <script src="../util/ext/gl-matrix.js"></script>
    <script src="../util/models/VertexDataGenerator.js"></script>
    <script src="../util/models/sphere-latlon.js"></script>
    <script src="../util/models/cube.js"></script>
    <script src="../util/models/cone.js"></script>
    <script src="../util/models/pine.js"></script>
    <script src="../util/models/torus.js"></script>
    <script src="../util/models/plane.js"></script>
    <script src="../util/models/Model.js"></script>
    <script src="../util/models/ModelAnimator.js"></script>
    <!-- main app -->
    <script src="main.js"></script>

    <!-- Shaders (app reads these by id at init) -->
    <script type="x-shader/x-vertex" id="vertexshader">
        attribute vec3 aPosition;
        attribute vec3 aNormal;
        attribute vec2 aTextureCoord;

        uniform mat4 uPMatrix;
        uniform mat4 uMVMatrix;
        uniform mat3 uNMatrix;

        varying vec3 vNormal;
        varying vec4 vPosition;
        varying vec2 vTextureCoord;

        void main(){
            // Calculate vertex position in eye coordinates. 
            vec4 tPosition = uMVMatrix * vec4(aPosition, 1.0);
            // Calculate projektion.
            gl_Position = uPMatrix * tPosition;

            vec3 tNormal = normalize(uNMatrix * aNormal);
            
            vPosition = tPosition;
            vNormal = tNormal;
            vTextureCoord = aTextureCoord;
        }
    </script>
    <script type="x-shader/x-fragment" id="fragmentshader">
        precision mediump float;

        varying vec3 vNormal;
        varying vec4 vPosition;
        varying vec2 vTextureCoord;

        // Texture
        uniform sampler2D uTexture;
        uniform bool uHasTexture;

        // Material.
        struct PhongMaterial {
            vec3 ka;
            vec3 kd;
            vec3 ks;
            float ke; 
        };
        uniform PhongMaterial material;

        // Ambient light.
        uniform vec3 ambientLight;

        // Pointlights.
        const int MAX_LIGHT_SOURCES = 8;
        struct LightSource {
            bool isOn;
            vec3 position;
            vec3 color;
        };
        uniform LightSource light[MAX_LIGHT_SOURCES];

        // Toon shading toggle
        uniform bool uToonShading;

        // Toon shading parameters
        const float TOON_DIFFUSE_THRESHOLD_HIGH = 0.5;  // High threshold for full color
        const float TOON_DIFFUSE_THRESHOLD_LOW = 0.1;   // Low threshold for medium shadow
        const float TOON_SPEC_THRESHOLD = 0.5;     // Threshold for specular highlights
        const float TOON_OUTLINE_THICKNESS = 0.25;  // Outline detection thickness
        const float TOON_SHADOW_BRIGHTNESS_MID = 0.3;   // Medium shadow brightness
        const float TOON_SHADOW_BRIGHTNESS_DARK = 0.1;  // Dark shadow brightness

        // Phong illumination for single light source with optional toon style
        // baseColor is used as kd (and optionally ks) when texture is present
        vec3 phongLight(vec3 p, vec3 n, vec3 v, LightSource l, bool useToon, vec3 baseColor) {

            vec3 L = l.color;
            vec3 lightDir = normalize(l.position - p);
            vec3 reflectDir = reflect(-lightDir, n);
            
            float diffuseIntensity = max(dot(lightDir, n), 0.0);
            float specularIntensity = max(dot(reflectDir, v), 0.0);

            vec3 result = vec3(0.0);

            if (useToon) {
                // Stylized Diffuse Illumination - Three levels
                if (diffuseIntensity >= TOON_DIFFUSE_THRESHOLD_HIGH) {
                    // Level 1: Full color in well-lit areas
                    result += baseColor * L;
                } else if (diffuseIntensity >= TOON_DIFFUSE_THRESHOLD_LOW) {
                    // Level 2: Medium shadow - slightly darker color
                    result += baseColor * L * TOON_SHADOW_BRIGHTNESS_MID;
                } else {
                    // Level 3: Dark shadow - darkest color
                    result += baseColor * L * TOON_SHADOW_BRIGHTNESS_DARK;
                }
                
                // Stylized Specular Highlights
                // Only show highlight if both normal and specular are above threshold
                if (diffuseIntensity > 0.0 && pow(specularIntensity, material.ke) > TOON_SPEC_THRESHOLD) {
                    result += material.ks * L;  // Add bright specular highlight
                }
            } else {
                // Standard Phong shading
                vec3 diffuse = baseColor * L * diffuseIntensity;
                vec3 specular = material.ks * L * pow(specularIntensity, material.ke);
                result = diffuse + specular;
            }

            return result;
        }

        // Detect outline based on view direction and normal
        // Creates uniform outline thickness across different geometries
        float getOutlineIntensity(vec3 n, vec3 v, float litIntensity) {
            // Normalize both vectors to get clean silhouettes
            vec3 normalizedN = normalize(n);
            vec3 normalizedV = normalize(v);
            
            float viewDot = dot(normalizedV, normalizedN);
            
            // Use smoothstep for smooth transitions at edges
            // This creates more uniform outlines regardless of geometry
            float baseSmoothness = TOON_OUTLINE_THICKNESS;
            
            // Apply smoothstep to detect silhouettes with consistent width
            // Smoother transition = more uniform outline width across geometries
            float outlineIntensity = smoothstep(baseSmoothness, -baseSmoothness * 0.3, viewDot);
            
            // Optional: slightly thicker on unlit surfaces
            outlineIntensity *= mix(1.3, 1.0, litIntensity);
            
            return outlineIntensity;
        }

        // Phong illumination for multiple light sources with optional texture blending
        vec3 phong(vec3 p, vec3 n, vec3 v) {

            // Get the base color: either from texture or from material
            vec3 baseColor = material.kd;
            if (uHasTexture) {
                vec4 texColor = texture2D(uTexture, vTextureCoord);
                baseColor = texColor.rgb;
            }

            // Calculate ambient light.
            vec3 result = material.ka * ambientLight;

            // Track if surface is lit for outline calculation
            float maxLitIntensity = 0.0;

            // Add light from all light sources.
            for(int j=0; j < MAX_LIGHT_SOURCES; j++){
                if(light[j].isOn){
                    vec3 lightDir = normalize(light[j].position - p);
                    float litIntensity = max(dot(lightDir, n), 0.0);
                    maxLitIntensity = max(maxLitIntensity, litIntensity);
                    result += phongLight(p, n, v, light[j], uToonShading, baseColor);
                }
            }

            // Apply outlines if toon shading is enabled
            if (uToonShading) {
                float outlineIntensity = getOutlineIntensity(n, v, maxLitIntensity);
                if (outlineIntensity > 0.0) {
                    // Render outline in dark color
                    result = vec3(0.1, 0.1, 0.1);  // Dark outline
                }
            }
            
            return result;
        }

        void main() {
            // Calculate view vector.
            vec3 v = normalize(-vPosition.xyz);

            vec3 vNormal = normalize(vNormal);

            gl_FragColor = vec4( phong(vPosition.xyz, vNormal, v), 1.0);
        }
    </script>
</head>

<body onload="app.start()">
    <main>
        <nav class="breadcrumb" aria-label="Breadcrumb">
            <a href="../index.html">← Zurück zur Übersicht</a>
        </nav>

        <h1>EA9 - Torustextur - Pascal Hürten</h1>

        <section id="viewer" aria-labelledby="viewer-heading">
            <h2 id="viewer-heading">Torustextur</h2>

            <div id="canvas-wrap" style="text-align: center; margin: 20px 0;">
                <canvas id="canvas" width="700" height="700"
                    style="border: 1px solid #ccc; border-radius: 4px; max-width:100%; height:auto;"></canvas>
            </div>
            <div
                style="max-width:700px;margin:12px auto 30px; text-align:left; background:#fff; border:1px solid #e6e6e6; padding:10px; border-radius:6px; display:flex;align-items:center;gap:12px; gap: 3em;">

                <div style="display:flex; gap:8px; align-items:center;"><strong
                        style=" margin-right:8px;">Kamera:</strong>
                    <button id="play-pause" aria-label="Play Pause Rotation"
                        style="font-size:14px;padding:6px 10px;">Play ▶</button>
                </div>
                <div style="display:flex; gap:8px; align-items:center;">
                    <strong style="margin-right:8px;">Lichter:</strong>
                    <button id="light-play-pause" aria-label="Play Pause Lights"
                        style="font-size:14px;padding:6px 10px;">Pause ❚❚</button>
                </div>
            </div>
            <div id="key-help"
                style="max-width:700px;margin:0 auto 20px; text-align:left; background:#fff; border:1px solid #e6e6e6; padding:12px; border-radius:6px; box-shadow:0 1px 2px rgba(0,0,0,0.04);">
                <div style="display:flex;justify-content:space-between;align-items:center;">
                    <strong>Tastatur-Steuerung</strong>
                </div>
                <ul style="margin:8px 0 0 16px;padding:0;color:#333;line-height:1.4;">
                    <li><strong>l / L</strong>: Lichter manuell forwährts steppen</li>
                    <li><strong>k / K</strong>: Lichter Pause/Play</li>
                    <li><strong>t / T</strong>: Toon Shading an/aus</li>
                    <li><strong>← / a , → / d</strong>: Kamera um Szene drehen</li>
                    <li><strong>w / s</strong>: Kameraneigung (Pitch) ändern</li>
                    <li><strong>o</strong>: Orthografische Projektion</li>
                    <li><strong>p</strong>: Perspektivische Projektion</li>
                    <li><strong>f</strong>: Frustum-Projektion</li>
                    <li><strong>n / N</strong>: Kamera weiter / näher</li>
                </ul>
            </div>
        </section>

        <section id="doc">
            <h2>Dokumentation</h2>


        </section>
    </main>
</body>

</html>