<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>EA6 | Objekte bewegen | Pascal Hürten</title>
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="../ea2/style.css">
    <style>
        .math-formula {
            background: #f5f5f5;
            padding: 12px;
            margin: 10px 0;
            border-left: 4px solid #0066cc;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            overflow-x: auto;
        }

        .shape-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .shape-section h4 {
            margin-top: 0;
            color: #0066cc;
        }
    </style>

    <!-- libraries & geometry generators -->
    <script src="../util/ext/gl-matrix.js"></script>
    <script src="../util/models/VertexDataGenerator.js"></script>
    <script src="../util/models/sphere.js"></script>
    <script src="../util/models/cube.js"></script>
    <script src="../util/models/cone.js"></script>
    <script src="../util/models/torus.js"></script>
    <script src="../util/models/plane.js"></script>
    <script src="../util/models/Model.js"></script>
    <script src="../util/models/ModelAnimator.js"></script>
    <!-- main app -->
    <script src="main.js"></script>

    <!-- Shaders (app reads these by id at init) -->
    <script type="x-shader/x-vertex" id="vertexshader">#version 300 es
in vec3 aPosition;
in vec3 aNormal;

uniform mat4 uPMatrix;
uniform mat4 uMVMatrix;
uniform mat3 uNormalMatrix;

out vec3 vNormal;
out vec3 vPosition;

void main(){
	// compute position in view (model-view) space
	vec4 mvPos = uMVMatrix * vec4(aPosition, 1.0);
	gl_Position = uPMatrix * mvPos;
	// pass normal and position to fragment shader
	vNormal = normalize(uNormalMatrix * aNormal);
	vPosition = mvPos.xyz;
}
</script>
    <script type="x-shader/x-fragment" id="fragmentshader">#version 300 es
precision mediump float;
in vec3 vNormal;
in vec3 vPosition;

uniform vec3 uModelColor;
uniform vec3 uLightDirection;
uniform float uAmbientStrength;
uniform float uShadowStrength; // 0..1 how strong shadows get
uniform float uShadowExponent; // controls falloff of shadow

out vec4 fragColor;

void main() {
	vec3 N = normalize(vNormal);
	vec3 L = normalize(uLightDirection);
	float diffuse = max(dot(N, -L), 0.0);

	// basic lighting (ambient + diffuse)
	float lighting = uAmbientStrength + diffuse * (1.0 - uAmbientStrength);

	// shadow factor: stronger when diffuse is small
	float shadowFactor = pow(1.0 - diffuse, uShadowExponent);
	float shadow = clamp(uShadowStrength * shadowFactor, 0.0, 1.0);

	// lit color
	vec3 litColor = uModelColor * lighting;

	// dark base for shadows (very low ambient in deep shadow)
	vec3 shadowColor = uModelColor * (uAmbientStrength * 0.25);

	// blend between shadowColor and litColor depending on shadow
	vec3 color = mix(litColor, shadowColor, shadow);

	fragColor = vec4(color, 1.0);
}
</script>

</head>

<body onload="app.start()">
    <main>
        <nav class="breadcrumb" aria-label="Breadcrumb">
            <a href="../index.html">← Zurück zur Übersicht</a>
        </nav>

        <h1>EA6 - Objekte bewegen - Pascal Hürten</h1>

        <section id="viewer" aria-labelledby="viewer-heading">
            <h2 id="viewer-heading">Fliegende Kugeln</h2>

            <div id="canvas-wrap" style="text-align: center; margin: 20px auto;">
                <canvas id="canvas" width="700" height="700"
                    style="border: 1px solid #ccc; border-radius: 4px; max-width:100%; height:auto;"></canvas>
            </div>
            <div id="control-widget"
                style="text-align:left; margin-bottom: 10px; background:#fff; border:1px solid #e6e6e6; padding:10px; border-radius:6px; display:flex;align-items:center;gap:12px;">
                <div style="display:flex; gap:8px; align-items:center;">
                    <button id="play-pause" aria-label="Play Pause Rotation"
                        style="font-size:14px;padding:6px 10px;">Play ▶</button>
                </div>
            </div>
            <div id="key-help"
                style="text-align:left; background:#fff; border:1px solid #e6e6e6; padding:12px; border-radius:6px; box-shadow:0 1px 2px rgba(0,0,0,0.04);">
                <div style="display:flex;justify-content:space-between;align-items:center;">
                    <strong>Tastatur-Steuerung</strong>
                </div>
                <ul style="margin:8px 0 0 16px;padding:0;color:#333;line-height:1.4;">
                    <li><strong>k</strong>: Animation 1-Schritt fortsetzen</li>
                    <li><strong>K</strong>: Animation pausieren/fortsetzen</li>
                    <li><strong>← / a , → / d</strong>: Kamera um Szene drehen</li>
                    <li><strong>w / s</strong>: Kameraneigung (Pitch) ändern</li>
                    <li><strong>o</strong>: Orthografische Projektion</li>
                    <li><strong>p</strong>: Perspektivische Projektion</li>
                    <li><strong>f</strong>: Frustum-Projektion</li>
                    <li><strong>n / N</strong>: Kamera weiter / näher</li>
                </ul>
            </div>
        </section>

        <section id="doc">
            <h2>Dokumentation</h2>

            <!-- ARCHITEKTUR -->
            <div class="shape-section">
                <h3>1. Architektur & Verantwortlichkeiten</h3>
                <h4>Schichten-Struktur</h4>
                <p>Die Anwendung ist in drei klar abgetrennte Schichten aufgebaut, jede mit eigener Verantwortung:</p>

                <h4>A. Vertex Data Generation (Geometrie-Ebene)</h4>
                <ul style="margin: 10px 0 20px 0;">
                    <li><strong>Dateien:</strong> <code>sphere.js</code>, <code>torus.js</code>, <code>plane.js</code>,
                        etc.</li>
                    <li><strong>Verantwortung:</strong> Erzeugt reine Geometrie-Daten (Vertices, Normals, Indizes)</li>
                    <li><strong>Klasse:</strong> Jede Geometry-Klasse (z.B. <code>Sphere</code>, <code>Torus</code>)
                        erbt von <code>VertexDataGenerator</code></li>
                    <li><strong>Methoden:</strong>
                        <ul>
                            <li><code>generateVertices()</code> - Berechnet Position aller Punkte auf der Fläche</li>
                            <li><code>generateNormals()</code> - Berechnet Oberflächennormalen für korrekte Beleuchtung
                            </li>
                            <li><code>generateIndices()</code> - Definiert welche Vertices zu Dreiecken verbunden werden
                            </li>
                        </ul>
                    </li>
                    <li><strong>Keine Abhängigkeiten:</strong> Kennt nichts von Rendering, Animation oder Szene</li>
                </ul>

                <h4>B. Model Rendering (Rendering-Ebene)</h4>
                <ul style="margin: 10px 0 20px 0;">
                    <li><strong>Datei:</strong> <code>Model.js</code></li>
                    <li><strong>Verantwortung:</strong> Verwaltet WebGL-Buffer und Rendering-Optionen</li>
                    <li><strong>Klasse:</strong> <code>Model</code></li>
                    <li><strong>Aufgaben:</strong>
                        <ul>
                            <li>Nimmt Vertex-Daten von VertexDataGenerator entgegen</li>
                            <li>Erstellt VBOs (Vertex Buffer Objects) und IBOs (Index Buffer Objects)</li>
                            <li>Speichert Rendering-Status (Farbe, Wireframe/Solid, Transform)</li>
                            <li>Speichert die <code>mvMatrix</code> (Model-View Matrix) für Position/Rotation/Skalierung
                            </li>
                        </ul>
                    </li>
                    <li><strong>Entkoppelung:</strong> Kennt nicht wie das Modell bewegt wird, nur wo es aktuell ist
                    </li>
                </ul>

                <h4>C. Animation & Transformation (Animation-Ebene)</h4>
                <ul style="margin: 10px 0 20px 0;">
                    <li><strong>Datei:</strong> <code>ModelAnimator.js</code></li>
                    <li><strong>Verantwortung:</strong> Modifiziert die mvMatrix eines Models im Laufe der Zeit</li>
                    <li><strong>Klasse:</strong> <code>ModelAnimator</code></li>
                    <li><strong>Konzept:</strong>
                        <ul>
                            <li>Akzeptiert ein <code>animationFn</code> - eine Funktion die sagt wie sich ein Objekt
                                bewegen soll</li>
                            <li>Ruft diese Funktion jeden Frame mit der verstrichenen Zeit auf</li>
                            <li>Die Funktion modifiziert die mvMatrix entsprechend</li>
                        </ul>
                    </li>
                    <li><strong>Presetsystem:</strong> <code>AnimationPresets</code> stellt vordefinierte
                        Bewegungsmuster bereit
                        <ul>
                            <li><code>rotateY(speed)</code> - Rotation um Y-Achse</li>
                            <li><code>orbit(radius, speed, center, offset, planeRotation)</code> - Kreisbahn mit
                                optionaler Neigung</li>
                            <li><code>combine(...functions)</code> - Kombiniert mehrere Animationen</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <!-- SYNCHRONISATION -->
            <div class="shape-section">
                <h3>2. Synchronisation: Kugeln & Torus</h3>
                <h4>Das Problem</h4>
                <p>Vier Kugeln umkreisen Offsets in 90° geneigten Ebenen. Ein Torus rotiert in der Mitte. Die
                    Herausforderung:</p>
                <ul>
                    <li>Kugeln müssen immer durch das Loch des Torus fliegen</li>
                    <li>Kugeln dürfen nicht mit dem Torus oder sich selbst kollidieren</li>
                    <li>Der Torus muss sich so drehen, dass das Loch immer in Flugrichtung zeigt</li>
                </ul>

                <h4>Die Lösung: Synchronisation durch Winkelgeschwindigkeit</h4>
                <p>Beide Bewegungen teilen die gleiche <strong>Winkelgeschwindigkeit (orbitSpeed)</strong>:</p>

                <div class="math-formula">
                    Kugelposition(t) = center + radius · (cos(ωt + φ), 0, sin(ωt + φ))<br>
                    Torusrotation(t) = -ωt (um Y-Achse)<br>
                    <br>
                    wobei:<br>
                    ω = Winkelgeschwindigkeit (orbitSpeed = 1.0 rad/s)<br>
                    t = Zeit in Sekunden<br>
                    φ = Offset (startAngle) für jede Kugel<br>
                </div>

                <h4>Torusrotation & Bewegung</h4>
                <p>Der Torus kombiniert drei Bewegungen für eine natürlichere, dynamischere Bewegung:</p>
                <div class="math-formula">
                    rotationY(t) = -ωt<br>
                    rotationX(t) = -2ωt (doppelte Geschwindigkeit)<br>
                    bob(t) = amplitude · sin(2π · frequency · t + phaseOffset)<br>
                    <br>
                    wobei:<br>
                    ω = orbitSpeed = 1.0 rad/s<br>
                </div>

                <h4>Code Beispiel (aus main.js)</h4>
                <div class="math-formula">
                    const orbitSpeed = 1.0; // radians/sec<br>
                    const bobsPerRotation = 4;<br>
                    const bobFrequency = (bobsPerRotation * orbitSpeed) / (2 * Math.PI);<br>
                    const bobPhaseOffset = Math.PI / 2;<br>
                    <br>
                    // Kugeln: alle benutzen gleiche orbitSpeed<br>
                    animationFn: AnimationPresets.orbit(<br>
                    &nbsp;&nbsp;orbitRadius, // 1.42<br>
                    &nbsp;&nbsp;orbitSpeed, // 1.0 (positiv = vorwärts)<br>
                    &nbsp;&nbsp;offset.center,<br>
                    &nbsp;&nbsp;offset.offset // π oder 3π<br>
                    )<br>
                    <br>
                    // Torus: kombinierte Rotationen und Bob<br>
                    animationFn: AnimationPresets.combine(<br>
                    &nbsp;&nbsp;AnimationPresets.rotateY(-orbitSpeed),<br>
                    &nbsp;&nbsp;AnimationPresets.rotateX(-orbitSpeed * 2),<br>
                    &nbsp;&nbsp;AnimationPresets.bob(0.1, bobFrequency, 0.02, bobPhaseOffset)<br>
                    )<br>
                </div>
            </div>
            <!-- ORBIT MATHEMATIK & MATRIX TRANSFORMATIONEN -->
            <div class="shape-section">
                <h3>3. Orbit-Animation: Mathematik & WebGL Matrix-Transformationen</h3>

                <h4>Parametrische Kreisbahn</h4>
                <p>Die Orbit-Position wird für jedes Frame berechnet mit:</p>
                <div class="math-formula">
                    angle(t) = ω·t + φ<br>
                    position(t) = center + radius·(cos(angle), 0, sin(angle))<br>
                    <br>
                    wobei ω = Winkelgeschwindigkeit, φ = Startwinkel, t = Zeit
                </div>

                <h4>WebGL Matrix-Transformationen</h4>
                <p>Die Position wird durch Translation und Rotation auf die mvMatrix angewendet (wichtig: Translate vor
                    Rotate, da Matrixmultiplikation nicht kommutativ):</p>
                <div class="math-formula">
                    const angle = speed * time + offsetAngle;<br>
                    const x = radius * Math.cos(angle);<br>
                    const z = radius * Math.sin(angle);<br>
                    <br>
                    mat4.translate(mvMatrix, mvMatrix, [center[0] + x, center[1], center[2] + z]);<br>
                    mat4.rotateY(mvMatrix, mvMatrix, -angle);
                </div>
            </div>
        </section>
    </main>
</body>

</html>